To implement a last-in-first-out (LIFO) stack using two queues, you can follow this approach:

Use two queues, let's call them queue1 and queue2.

When you push an element onto the stack, always push it into queue1.

When you pop an element from the stack, move all elements from queue1 to queue2, except for the last element. This last element will be the one you want to remove (pop). Then, swap the names of queue1 and queue2.

The top of the stack is always the last element in queue1.

Here's the C++ code to implement this LIFO stack using two queues:

class MyStack {
public:
queue<int>q;
    MyStack() {
        
    }
    
    void push(int x) {
        q.push(x);
        int v=q.size()-1;
        int i=0;
        while(i<v){
          q.push(q.front());
          i++;
          q.pop();
        }
    }
    
    int pop() {
        int p=q.front();
        q.pop();
        return p;
    }
    
    int top() {
      return q.front();  
    }
    
    bool empty() {
        return q.size()==0;
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */


OR



#include <queue>

class MyStack {
public:
    MyStack() {}

    void push(int x) {
        q1.push(x);
    }

    int pop() {
        while (q1.size() > 1) {
            q2.push(q1.front());
            q1.pop();
        }
        int top_element = q1.front();
        q1.pop();

        std::swap(q1, q2); // Swap the names of the queues
        return top_element;
    }

    int top() {
        return q1.front();
    }

    bool empty() {
        return q1.empty();
    }

private:
    std::queue<int> q1, q2;
};


